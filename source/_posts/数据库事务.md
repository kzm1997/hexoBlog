---
title: 数据库事务
categories:
  - mysql
index_img: >-
  https://199794.oss-cn-shanghai.aliyuncs.com/blog//2019-04-22%20135447_gaitubao_1600x900_1604366529483.jpg
date: 2021-10-24 15:06:32
---

## 什么是事务? 
事务是逻辑上的一组操作,要么都执行,要么都不执行  

比如现实中的转账业务,一个加钱,一个减钱,必须都成功 

### 原子性  
要么全都做,要么全不做的规则称之为原子性  

### 隔离性  
现实世界中的两次状态转换应该是互不影响的，比如说狗哥向猫爷同时进行的两次金额为5元的转账（假设可以在两个ATM机上同时操作）。那么最后狗哥的账户里肯定会少10元，猫爷的账户里肯定多了10元。但是到对应的数据库世界中，事情又变的复杂了一些。  
- 读取狗哥账户的余额到变量A中，这一步骤简写为 read(A)   
- 将狗哥账户的余额减去转账金额，这一步骤简写为 A = A - 5 
- 将狗哥账户修改过的余额写到磁盘里，这一步骤简写为 write(A 
- 读取猫爷账户的余额到变量B，这一步骤简写为 read(B)
- 将猫爷账户的余额加上转账金额，这一步骤简写为 B = B + 5
- 将猫爷账户修改过的余额写到磁盘里，这一步骤简写为 write(B)

我们将狗哥向猫爷同时进行的两次转账操作分别称为 T1 和 T2 ，在现实世界中 T1 和 T2 是应该没有关系的，可以先执行完 T1 ，再执行 T2 ，或者先执行完 T2 ，再执行 T1 ，对应的数据库操作就像这样
![Snipaste_20210523_112414.png](http://oss.xiaokoua.cn/blog//Snipaste_2021-05-23_11-24-14_1621740267013.png)  
真实的数据库中 T1 和 T2 的操作可能交替执行
![Snipaste_20210523_112511.png](http://oss.xiaokoua.cn/blog//Snipaste_2021-05-23_11-25-11_1621740327638.png)
所以隔离性为并发访问数据库时,一个用户的事务不会被其他事务所干扰,各并发事务之间数据库是独立的  

### 一致性  
比如转账业务,每完成一笔交易后,都需要保证整个系统的余额不变,无论事务是否成功,转账者和收款人的总额不变  

### 持久性  
一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。  

### 事务的状态  

根据事务执行的不同阶段,事务大致上划分成了几个状态:  
-  **活动的(active)**  事务对应的数据库操作正在执行过程中时,我们就说该事务处在活动的状态  
- **部分提交的(partially commited)** 当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并没有刷新到磁盘时，我们就说该事务处在 部分提交的 状态。  
- **失败的（failed)** 当事务处在 活动的 或者 部分提交的 状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在 失败的 状态.  
- **中止的（aborted)** 如果事务执行了半截而变为 失败的 状态，比如我们前边唠叨的狗哥向猫爷转账的事务，当狗哥账户的钱被
扣除，但是猫爷账户的钱没有增加时遇到了错误，从而当前事务处在了 失败的 状态，那么就需要把已经修改的狗哥账户余额调整为未转账之前的金额，换句话说，就是要撤销失败事务对当前数据库造成的影响。书面一点的话，我们把这个撤销的过程称之为 回滚 。当 回滚 操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了 中止的 状态。  
- **提交的（committed）** 当一个处在 部分提交的 状态的事务将修改过的数据都同步到磁盘上之后，我们就可以说该事务处在了 提交的 状态。  

![Snipaste_20210523_114845.png](http://oss.xiaokoua.cn/blog//Snipaste_2021-05-23_11-48-45_1621741735441.png)

